#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
multi_usage() {
  if [[ -n $long_usage ]]; then
    echo -e "multi"
    echo 
    echo -e "  Multiline test\n  \n  This is a multiline test example. Long lines are going to be properly wrapped\n  at the 80 character mark."
    echo 
  else
    echo -e "multi - Multiline test"
    echo 
  fi
  echo -e "Usage:"
  echo -e "  multi [command] [options]"
  echo -e "  multi [command] --help | -h"
  echo -e "  multi --version"
  echo
  # :command.usage_commands
  echo -e "Commands:"
  echo "  multiline   Do some multiline work."
  echo "  regular     Standard help line"
  echo

  if [[ -n $long_usage ]]; then
    echo -e "Options:"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    echo -e "    Show this help"
    echo
    echo "  --version"
    echo -e "    Show version number"
    echo

    # :command.usage_environment_variables
    echo -e "Environment Variables:"
    echo "  MULTI_VITAMIN"
    echo -e "    Environment variables can also use multiple lines. This can be useful if we\n    need to explain - in excruciating detail - what the environemnt variable is\n    used for."
    echo
    # :command.usage_examples
    echo -e "Examples:"
    
    echo -e "  Examples can also use multiple lines. This can be useful if we need to explain\n  the example, for instance like we are doing here:\n  \n    multi multiline --flag"
    echo

  fi
}

# :command.usage
multi_multiline_usage() {
  if [[ -n $long_usage ]]; then
    echo -e "multi multiline"
    echo 
    echo -e "  Do some multiline work.\n  \n  This is a long process and takes time, therefore it takes a lot of lines to\n  describe and this line is particularly long.\n  \n  But - not all hope is lost. Bashly should respect newlines and word-wrap long\n  lines properly at the 80 character mark."
    echo 
  else
    echo -e "multi multiline - Do some multiline work."
    echo 
  fi
  echo -e "Usage:"
  echo -e "  multi multiline [MY_ARG] [options]"
  echo -e "  multi multiline --help | -h"
  echo

  if [[ -n $long_usage ]]; then
    echo -e "Options:"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    echo -e "    Show this help"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --long"
    echo -e "    Long flag with long text.\n    \n    Finally, this will be the last multiline string we type (hopefully), but\n    once we are done with this, we will be done with all."
    echo
    # :command.usage_args
    echo -e "Arguments:"
    
    # :argument.usage
    echo "  MY_ARG"
    echo -e "    Argument with multiline.\n    \n    Once again we gather here to prepare some long lines that will most likely\n    seem silly to anyone who reads them.\n    \n    But, it is just needed for testing - otherwise, it will not only be silly,\n    but it will also be buggy!"
    echo

  fi
}

# :command.usage
multi_regular_usage() {
  if [[ -n $long_usage ]]; then
    echo -e "multi regular - Standard help line"
    echo 
  else
    echo -e "multi regular - Standard help line"
    echo 
  fi
  echo -e "Usage:"
  echo -e "  multi regular [REPO] [options]"
  echo -e "  multi regular --help | -h"
  echo

  if [[ -n $long_usage ]]; then
    echo -e "Options:"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    echo -e "    Show this help"
    echo

    # :command.usage_args
    echo -e "Arguments:"
    
    # :argument.usage
    echo "  REPO"
    echo -e "    Repository name"
    echo

  fi
}

# :command.inspect_args
inspect_args() {
  echo args:
  for k in "${!args[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
}

# :command.command_functions
# :command.function
multi_multiline_command() {
  # :src/multiline_command.sh
  echo "# this file is located in 'src/multiline_command.sh'"
  echo "# code for 'multi multiline' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.function
multi_regular_command() {
  # :src/regular_command.sh
  echo "# this file is located in 'src/regular_command.sh'"
  echo "# code for 'multi regular' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.parse_args
parse_args() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    multi_usage
    exit 1
    ;;
  
  esac
  # :command.command_filter
  action=$1
  
  case $action in
  -* )
    ;;
  
  multiline )
    action="multiline"
    shift
    multi_multiline_parse_args "$@"
    shift $#
    ;;    
  
  regular )
    action="regular"
    shift
    multi_regular_parse_args "$@"
    shift $#
    ;;    
  
  * )
    multi_usage
    exit 1
    ;;
  
  esac
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_args_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      echo -e "invalid option: $key"
      exit 1
      ;;
  
    * )
      # :command.parse_args_case
      echo -e "invalid argument: $key"
      exit 1
      ;;
  
    esac
  done
}

# :command.parse_args
multi_multiline_parse_args() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    multi_multiline_usage
    exit 1
    ;;
  
  esac
  # :command.command_filter
  action="multiline"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_args_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --long )
      args[--long]=1
      shift
      ;;
  
  
    -* )
      echo -e "invalid option: $key"
      exit 1
      ;;
  
    * )
      # :command.parse_args_case
      if [[ ! ${args[my_arg]} ]]; then
        args[my_arg]=$1
        shift
      else
        echo -e "invalid argument: $key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.parse_args
multi_regular_parse_args() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit 1
    ;;
  
  --help | -h ) 
    long_usage=yes
    multi_regular_usage
    exit 1
    ;;
  
  esac
  # :command.command_filter
  action="regular"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_args_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      echo -e "invalid option: $key"
      exit 1
      ;;
  
    * )
      # :command.parse_args_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      else
        echo -e "invalid argument: $key"
        exit 1
      fi
      ;;
  
    esac
  done
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e  

  # :src/initialize.sh
  # Code here runs inside the initialize() function
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  # CONFIG_FILE=settings.ini
  #
  # Feel free to empty (but not delete) this file.
}

# :command.run
run() {
  declare -A args
  parse_args "$@"

  if [[ $action == "multiline" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      multi_multiline_usage
    else
      multi_multiline_command
    fi
  
  elif [[ $action == "regular" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      multi_regular_usage
    else
      multi_regular_command
    fi
  
  elif [[ ${args[--version]} ]]; then
    version_command
  elif [[ ${args[--help]} ]]; then
    long_usage=yes
    multi_usage
  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
